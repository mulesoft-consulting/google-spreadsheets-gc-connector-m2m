/**
 * Mule Google Spreadsheets Cloud Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.mule.module.google.spreadsheet;

import com.google.api.client.googleapis.auth.oauth2.GoogleCredential;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.HttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.util.SecurityUtils;
import com.google.gdata.client.authn.oauth.OAuthException;
import com.google.gdata.client.docs.DocsService;
import com.google.gdata.client.spreadsheet.*;
import com.google.gdata.data.Link;
import com.google.gdata.data.Person;
import com.google.gdata.data.PlainTextConstruct;
import com.google.gdata.data.batch.BatchOperationType;
import com.google.gdata.data.batch.BatchUtils;
import com.google.gdata.data.spreadsheet.*;
import com.google.gdata.util.ServiceException;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.mule.api.ConnectionException;
import org.mule.api.ConnectionExceptionCode;
import org.mule.api.annotations.Connect;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.display.Password;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.module.google.spreadsheet.model.Cell;
import org.mule.module.google.spreadsheet.model.*;
import org.mule.module.google.spreadsheet.model.Worksheet;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.security.PrivateKey;
import java.util.Arrays;
import java.util.List;

/**
 * Connector for accessing, creating and modifying google docs spreadsheets.
 * This connector uses OAuth2 for authentication.
 *
 * @author mariano.gonzalez@mulesoft.com
 */
@Connector(name="google-spreadsheets", schemaVersion="1.0", friendlyName="Google Spreadsheets", minMuleVersion="3.5" )
public class GoogleSpreadSheetConnector {
	
	private static Logger logger = Logger.getLogger(GoogleSpreadSheetConnector.class);
	
	@SuppressWarnings("rawtypes")
	private static final List SCOPES = Arrays.asList("https://spreadsheets.google.com/feeds");
	private static final JsonFactory JSON_FACTORY = new JacksonFactory();

	private static HttpTransport httpTransport = null;

	private FeedURLFactory factory = FeedURLFactory.getDefault();
	
	// Credentials
	private GoogleCredential credential;
	private String accessToken;
	
	private SpreadsheetService spreadsheetService;
	
	private DocsService docService;

	/**
	 * 
	 * @param applicationName
	 * @param serviceAccount
	 * @param scope
	 * @param privateKeyP12File
	 * 
	 * Initiate connection
	 */
	@SuppressWarnings("unchecked")
	@Connect
	public void connect(@ConnectionKey String applicationName, @Password String serviceAccount, String privateKeyP12File,  
			@Password String storePass, String alias, @Password String keyPass) 
		throws ConnectionException {
		
		logger.info(String.format("Logging into Google BigQuery application %s.", applicationName));
		
		try {
			InputStream in = this.getClass().getClassLoader().getResourceAsStream(privateKeyP12File);
			PrivateKey key = SecurityUtils.loadPrivateKeyFromKeyStore(SecurityUtils.getPkcs12KeyStore(), in, storePass, alias, keyPass);
			logger.trace("Key size: "+key.getEncoded().length);
			logger.trace("Key algorithm: "+key.getAlgorithm());
			
			httpTransport = GoogleNetHttpTransport.newTrustedTransport();
			
		    credential = new GoogleCredential.Builder().setTransport(httpTransport)
		            .setJsonFactory(JSON_FACTORY)
		            .setServiceAccountId(serviceAccount)
		            .setServiceAccountScopes(SCOPES)
		            .setServiceAccountPrivateKey(key)
		            .build();
		    
		    credential.refreshToken();
		    accessToken = credential.getAccessToken();
		    logger.trace("Assess token: " + credential.getAccessToken());
		    
    		this.spreadsheetService = new SpreadsheetService(applicationName);
    		this.spreadsheetService.setOAuth2Credentials(credential);
    		this.spreadsheetService.setProtocolVersion(SpreadsheetService.Versions.V3);
		    
	        logger.info("Sheet service client created: " + this.spreadsheetService.toString());
			
    		this.docService = new DocsService(applicationName);
    		this.docService.setOAuth2Credentials(credential);
    		this.docService.setProtocolVersion(DocsService.Versions.V3);
		    
	        logger.info("Sheet service client created: " + this.docService.toString());

		}
		catch (Exception ex) {
			ex.printStackTrace();
			logger.error(ex.getMessage());
			throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, ex.getMessage(), ex);
		}
		
	}

	/**
	 * Disconnect
	 * 
	 * @throws ConnectionException
	 */
	@Disconnect
	public void disconnect() throws ConnectionException {		
		try {
			spreadsheetService = null;
			docService = null;
		}
		catch (Exception ex) {
			ex.printStackTrace();
			logger.error(ex.getMessage());
			throw new ConnectionException(ConnectionExceptionCode.UNKNOWN, null, ex.getMessage(), ex);
		}
	}

	/**
	 * Validate connection
	 */
	@ValidateConnection
	public boolean isConnected()
	{
		boolean isConnected = false;
		if (spreadsheetService != null && docService != null)
			isConnected = true;
		
		return isConnected;
	}

	/**
	 * Session Access Token
	 */
	@ConnectionIdentifier
	public String connectionId() {
		String connectionId = credential.getAccessToken();
		logger.info("Connection Identifier: " + connectionId);
		return connectionId;
	}
	
    /**
     * Returns all the spreadsheets associated with the user's account
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-all-spreadsheets}
     * 
     * @return a list of @{link org.mule.module.google.spreadsheet.model.Spreadsheet}
     * @throws OAuthException if there's an error authenticating
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Spreadsheet> getAllSpreadsheets() throws OAuthException, IOException, ServiceException {
        return ModelParser.parseSpreadsheet(this.spreadsheetService.getFeed(factory.getSpreadsheetsFeedUrl(), SpreadsheetFeed.class));
    }
    
 
    /**
     * Creates a new spreadsheet using a given title
     *  
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:create-spreadsheet}
     *  
     * @param title the title you want the new spreadsheet to have
     * @throws OAuthException if there's an error authenticating
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public void createSpreadsheet(String title) throws OAuthException, IOException, ServiceException {

    	com.google.gdata.data.docs.SpreadsheetEntry newEntry = new com.google.gdata.data.docs.SpreadsheetEntry();
    	
    	newEntry.setTitle(new PlainTextConstruct(title));
        this.docService.insert(new URL("https://docs.google.com/feeds/default/private/full"), newEntry);
    }
    
    /**
     * Lists all the worksheets contained in an specified spreadsheet
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-all-worksheets}
     * 
     * @param spreadsheet the title of the spreadsheet you want to get the worksheets from
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Worksheet}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Worksheet> getAllWorksheets(String spreadsheet, @Default("0") int spreadsheetIndex) throws IOException, ServiceException {

        SpreadsheetEntry ss = this.getSpreadsheetEntry(spreadsheet, spreadsheetIndex);
    	return ModelParser.parseWorksheet(ss.getWorksheets());
    }
    
    /**
     * Creates a new worksheet for an specified spreadsheet
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:create-worksheet}
     *  
     * @param spreadsheet the title of the spreadsheet that will contain the new worksheet
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param title the title you want the new worksheet to have
     * @param rowCount the initial number of rows you want the worksheet to have
     * @param colCount the initial number of columns you want the worksheet to have
     * @return an instance of {@link org.mule.module.google.spreadsheet.model.Worksheet} representing the newly created worksheet
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public Worksheet createWorksheet(
			String spreadsheet,
            @Default("0") int spreadsheetIndex,
            String title,
    		int rowCount,
    		int colCount) throws IOException, ServiceException {
    	
    	SpreadsheetEntry ss = this.getSpreadsheetEntry(spreadsheet, spreadsheetIndex);
    	WorksheetEntry ws = new WorksheetEntry();
    	ws.setTitle(new PlainTextConstruct(title));
    	ws.setRowCount(rowCount);
    	ws.setColCount(colCount);
    	//This flag is not required when inserting a worksheet and if set, will make the call fail
    	ws = this.spreadsheetService.insert(ss.getWorksheetFeedUrl(), ws);
    	return new Worksheet(ws);
    }
    
    /**
     * Deletes an specified worksheet
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:delete-worksheet}
     * 
     * @param spreadsheet the title of the spreadsheet that contains the worksheet to be deleted
     * @param worksheet  the title of the worksheet you want to delete
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public void deleteWorksheet(
					String spreadsheet,
		    		String worksheet,
                    @Default("0") int spreadsheetIndex,
                    @Default("0") int worksheetIndex) throws IOException, ServiceException {

        WorksheetEntry ws = this.getItem(this.getWorksheetEntriesByTitle(spreadsheet, worksheet, spreadsheetIndex), worksheetIndex);
    	ws.delete();
    }
    
    /**
     * 
     * This processor allows updating a worksheet's metadata, constituted by
     * its title, dimensions, summary, draft and editability status.
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:update-worksheet-metadata}
     * 
     * @param spreadsheet the title of the spreadsheet you want to update
     * @param worksheet  the title of the worksheet you want to update
     * @param title if specified, it changes the title you want to set
     * @param draft if specified, it changes the value of the draft property
     * @param canEdit if specified, it changes the worksheet's editability
     * @param summary if specified, it changes the worksheet's summary
     * @param rowCount if a value greater than zero is specified, it changes the amount of rows in the worksheet
     * @param colCount if a value greater than zero is specified, it changes the amount of columns in the worksheet
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public void updateWorksheetMetadata(
			String spreadsheet,
    		String worksheet,
            @Default("") String title,
            @Optional Boolean draft,
    		@Optional Boolean canEdit,
            @Default("") String summary,
            @Default("0") int rowCount,
            @Default("0") int colCount,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex) throws IOException, ServiceException {

        WorksheetEntry ws = this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex);
		
    	if (!StringUtils.isEmpty(title)) {
    		ws.setTitle(new PlainTextConstruct(title));
    	}
    	
    	if (draft != null) {
    		ws.setDraft(draft);
    	}
    	
    	if (rowCount > 0) {
    		ws.setRowCount(rowCount);
    	}
    	
    	if (colCount > 0) {
    		ws.setColCount(colCount);
    		
    	}
    	
    	if (canEdit != null) {
    		ws.setCanEdit(canEdit);
    	}
    	
    	if (!StringUtils.isEmpty(summary)) {
    		ws.setSummary(new PlainTextConstruct(summary));
    	}
    	
    	ws.update();
    }
    
    /**
     * Performs a batch update of a worksheet's cells taking values from a list of {@link org.mule.module.google.spreadsheet.model.Row}
     * taken from the message payload.
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:set-row-values}
     * 
     * @param rows a list of {@link org.mule.module.google.spreadsheet.model.Row} taken from the message payload describing the values to be set
     * @param spreadsheet the title of the spreadsheet you want to update
     * @param worksheet  the title of the worksheet you want to update
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param purge if true, the worksheet will be purged before the values are set
     * @throws Exception if an error occurs
     */
    @Processor
    public void setRowValues(
            @Default("#[payload]") List<Row> rows,
            String spreadsheet,
    		String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex,
            @Default("false") boolean purge) throws Exception {

        if (rows == null || rows.isEmpty()) {
    		logger.warn("Worksheet contains no rows... skipping update and possible purge");
    		return;
    	}
    	
    	if (purge) {
    		this.purgeWorksheet(spreadsheet, worksheet, spreadsheetIndex, worksheetIndex);
    	}
    	
    	URL cellFeedUrl = this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex).getCellFeedUrl();
    	CellFeed batchRequest = new CellFeed();
    	
    	for (Row row : rows) {
    		for (Cell cell : row.getCells()) {
    			String batchId = "R" + row.getRowNumber() + "C" + cell.getColumnNumber();
    			URL entryUrl = new URL(cellFeedUrl.toString() + "/" + batchId);
    			CellEntry batchOperation = this.spreadsheetService.getEntry(entryUrl, CellEntry.class);
    			batchOperation.changeInputValueLocal(cell.getValueOrFormula());
    			BatchUtils.setBatchId(batchOperation, batchId);
    			BatchUtils.setBatchOperationType(batchOperation, BatchOperationType.UPDATE);
    			batchRequest.getEntries().add(batchOperation);
    		}
    	}
    	
        // Get the batch feed URL and submit the batch requests
        CellFeed feed = this.spreadsheetService.getFeed(cellFeedUrl, CellFeed.class);
        Link batchLink = feed.getLink(Link.Rel.FEED_BATCH, Link.Type.ATOM);
        URL batchUrl = new URL(batchLink.getHref());
        
        this.spreadsheetService.batch(batchUrl, batchRequest);
    }
    
    /**
     * 
     * Performs a batch update of a worksheet's cells taking values from a csv String.
     * This csv file can have multiple lines and columns and you get to specify what those separators are. 
     * You can manually specify the csv string or else it will automatically taken from the message payload
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:set-csv-values}
     * 
     * @param spreadsheet the title of the spreadsheet you want to update
     * @param worksheet  the title of the worksheet you want to update
     * @param csv the csv content to be set on the worksheet. You can manually specify it or else it will be taken from the message payload
     * @param startingRow the number of the row where the first line of the csv will be set into. This is a 1-based index
     * @param startingColumn the number of the column where the first value of each line of the csv will be set into. This is a 1-based index
     * @param lineSeparator specifies the character to be used as a line separator. Defaults to the new line <code>\n</code> character
     * @param columnSeparator specifies the character to be used as a column sperator. Defaults to a comma character
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param purge if true, the worksheet will be purged before the values are set
     * @throws Exception if an error occurs
     */
    @Processor
    public void setCsvValues(
			String spreadsheet,
    		String worksheet,
            @Default("#[payload]") String csv,
            @Default("1") int startingRow,
            @Default("1") int startingColumn,
            @Default("\n") String lineSeparator,
            @Default(",") String columnSeparator,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex,
            @Default("false") boolean purge) throws Exception {

        if (StringUtils.isEmpty(csv)) {
    		if (logger.isDebugEnabled()) {
    			logger.debug("received empty csv value... exiting without updating values nor purging");
    		}
    		return;
    	}
    	
    	if (StringUtils.isEmpty(lineSeparator)) {
    		lineSeparator = "\n";
    	}
    	
    	if (StringUtils.isEmpty(",")) {
    		columnSeparator = ",";
    	}
    	
    	List<Row> rows = CsvToRowsAdapter.adapt(csv, startingRow, startingColumn, columnSeparator, lineSeparator);
    	this.setRowValues(rows, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex, purge);
    }

    /**
     * Returns a list of {@link com.google.gdata.data.Person} where each entry represent a a contributor
     * on a specified spreadsheet
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-authors}
     * 
     * @param spreadsheet the title of the spreadsheet from which the info should be taken from
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @return a list of {@link com.google.gdata.data.Person} where each entry represent a spreadsheet's contributor
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Person> getAuthors(String spreadsheet, @Default("0") int spreadsheetIndex) throws IOException, ServiceException {
    	
    	return this.getSpreadsheetEntry(spreadsheet, spreadsheetIndex).getAuthors();
    }
    
    /**
     * This processor returns the a worksheet's first row
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-column-headers}
     * 
     * @param spreadsheet the title of the spreadsheet from which the info should be taken from
     * @param worksheet the title of the worksheet from which the info should be taken from
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @return an instance of  {@link org.mule.module.google.spreadsheet.model.Row} is the worksheet has a first row
     * 			initialized, null otherwise
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public Row getColumnHeaders(
			String spreadsheet,
    		String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex) throws IOException, ServiceException {


        WorksheetEntry worksheetEntry = this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex);
    	
		// Get the appropriate URL for a cell feed
		URL cellFeedUrl = worksheetEntry.getCellFeedUrl();

		// Create a query for the top row of cells only (1-based)
		CellQuery cellQuery = new CellQuery(cellFeedUrl);
		cellQuery.setMaximumRow(1);

		// Get the cell feed matching the query
		CellFeed topRowCellFeed = this.spreadsheetService.query(cellQuery, CellFeed.class);

		List<Row> rows = ModelParser.parseCell(topRowCellFeed);
		
		return rows.isEmpty() ? null : rows.get(0);
    }
    
    /**
     * This processor returns the a worksheet's first row
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-row}
     * 
     * @param spreadsheet the title of the spreadsheet from which the info should be taken from
     * @param worksheet the title of the worksheet from which the info should be taken from
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * 
     * @param rowNum Row number
     * 
     * @return an instance of  {@link org.mule.module.google.spreadsheet.model.Row} is the worksheet has row at the given number, null otherwise
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public Row getRow(
			String spreadsheet,
    		String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex,
            Integer rowNum) throws IOException, ServiceException {


        WorksheetEntry worksheetEntry = this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex);
    	
		// Get the appropriate URL for a cell feed
		URL cellFeedUrl = worksheetEntry.getCellFeedUrl();

		// Create a query for the given row number
		CellQuery cellQuery = new CellQuery(cellFeedUrl);
		cellQuery.setMinimumRow(rowNum);
		cellQuery.setMaximumRow(rowNum);

		// Get the cell feed matching the query
		CellFeed topRowCellFeed = this.spreadsheetService.query(cellQuery, CellFeed.class);

		List<Row> rows = ModelParser.parseCell(topRowCellFeed);
		
		return rows.isEmpty() ? null : rows.get(0);
    }
    
    /**
     * Returns a list of {@link org.mule.module.google.spreadsheet.model.Spreadsheet} with all the spreadsheets
     * associated with the user which title matches the one specified.
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-spreadsheets-by-title}
     * 
     * @param title the title to be used in the search
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Spreadsheet}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Spreadsheet> getSpreadsheetsByTitle(String title) throws IOException, ServiceException {
    	SpreadsheetQuery spreadsheetQuery = new SpreadsheetQuery(factory.getSpreadsheetsFeedUrl());
        spreadsheetQuery.setTitleQuery(title);
        return ModelParser.parseSpreadsheet(this.spreadsheetService.query(spreadsheetQuery, SpreadsheetFeed.class));
    }

    /**
     * Returns a list of {@link org.mule.module.google.spreadsheet.model.Worksheet} 
     * which title matches the one specified. This is not a global search. Only worksheets
     * attached to a specified spreadsheet will be considered
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-worksheet-by-title}
     * 
     * @param spreadsheet the title of the spreadsheet in which you want to perform the search
     * @param title the title to be used in the search
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Worksheet} 
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Worksheet> getWorksheetByTitle(
    							String spreadsheet,
    				    		String title,
                                @Default("0") int spreadsheetIndex) throws IOException, ServiceException {

        return ModelParser.parseWorksheet(this.getWorksheetEntriesByTitle(spreadsheet, title, spreadsheetIndex));
    }
    
    /**
     * This processors deletes all the cell entries of a specified worksheet.
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:purge-worksheet}
     * 
     * @param spreadsheet the title of the spreadsheet containing the worksheet to be purged
     * @param worksheet the title of the worksheet to be purged
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public void purgeWorksheet(
			String spreadsheet,
    		String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex) throws IOException, ServiceException {

        WorksheetEntry worksheetEntry = this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex);
    	
    	CellFeed cellFeed = this.spreadsheetService.getFeed(worksheetEntry.getCellFeedUrl(), CellFeed.class);

    	for (CellEntry cell : cellFeed.getEntries()) {
    		cell.delete();
    	}
    }
    
    /**
     * Returns a list of {@link org.mule.module.google.spreadsheet.model.Row} in which each
     * entry represents one of the initialized cells on a worksheet
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-all-cells}
     * 
     * @param spreadsheet the title of the spreadsheet containing the worksheet on which the cells are
     * @param worksheet the title of the worksheet containing the cells you want to get
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Cell}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Row> getAllCells(
			String spreadsheet,
    		String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex) throws IOException, ServiceException {

        WorksheetEntry worksheetEntry = this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex);

    	// Get the appropriate URL for a cell feed
    	URL cellFeedUrl = worksheetEntry.getCellFeedUrl();
    	return ModelParser.parseCell(this.spreadsheetService.getFeed(cellFeedUrl, CellFeed.class));
    }
    
    /**
     * Returns a CSV file representing all the initialized cells in a worksheet.
     * Athough this method is intended for generating a CSV file, notice that
     * the column and line separator are customizable so you could use it
     * to generated a text delimited file that is not strictly speaking a CSV.
     * 
     * The generated file will have one line per cell and the following columns structure
     * 
     * Row Number | Column Number | evaluated Value
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-all-cells-as-csv}
     * 
     * @param spreadsheet the title of the spreadsheet containing the worksheet on which the cells are
     * @param worksheet the title of the worksheet containing the cells you want to get
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param lineSeparator specifies the character to be used as a line separator. Defaults to the new line <code>\n</code> character
     * @param columnSeparator specifies the character to be used as a column sperator. Defaults to a comma character
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Cell}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public String getAllCellsAsCsv(
			String spreadsheet,
    		String worksheet,
            @Default(",") String columnSeparator,
            @Default("\n") String lineSeparator,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex) throws IOException, ServiceException {

        if (StringUtils.isEmpty(lineSeparator)) {
    		lineSeparator = "\n";
    	}
    	
    	if (StringUtils.isEmpty(",")) {
    		columnSeparator = ",";
    	}
    	
    	return ModelParser.toCSV(this.getAllCells(spreadsheet, worksheet, spreadsheetIndex, worksheetIndex),
    				lineSeparator, columnSeparator);
    }
    
    /**
     * Returns a list of {@link org.mule.module.google.spreadsheet.model.Row} containing
     * the cells contained in a given range
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-cell-range}
     * 
     * @param spreadsheet the title of the spreadsheet containing the worksheet on which the cells are
     * @param worksheet the title of the worksheet containing the cells you want to get
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param minRow the range starting row. This is a 1-based index
     * @param maxRow the range ending row. This is a 1-based index
     * @param minCol the range starting column. This is a 1-based index
     * @param maxCol the range ending column. This is a 1-based index
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Row}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Row> getCellRange(
			String spreadsheet,
			String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex,
            @Optional Integer minRow,
    		@Optional Integer maxRow,
    		@Optional Integer minCol,
    		@Optional Integer maxCol) throws IOException, ServiceException {
      
    	CellQuery query = new CellQuery(this.getCellFeedUrl(spreadsheet, worksheet, spreadsheetIndex, worksheetIndex));
    	query.setMinimumRow(minRow);
	    query.setMaximumRow(maxRow);
	    query.setMinimumCol(minCol);
	    query.setMaximumCol(maxCol);
	    
	    return ModelParser.parseRows(this.spreadsheetService.query(query, CellFeed.class));
    }
    
    /**
     * Returns a CSV file representing the requested cell range.
     * Athough this method is intended for generating a CSV file, notice that
     * the column and line separator are customizable so you could use it
     * to generated a text delimited file that is not strictly speaking a CSV.
     * 
     * The generated file will have one line per cell and the following columns structure
     * 
     * Row Number | Column Number | evaluated Value
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:get-cell-range-as-csv}
     * 
     * @param spreadsheet the title of the spreadsheet containing the worksheet on which the cells are 
     * @param worksheet the title of the worksheet containing the cells you want to get
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param minRow the range starting row. This is a 1-based index
     * @param maxRow the range ending row. This is a 1-based index
     * @param minCol the range starting column. This is a 1-based index
     * @param maxCol the range ending column. This is a 1-based index
     * @param lineSeparator specifies the character to be used as a line separator. Defaults to the new line <code>\n</code> character
     * @param columnSeparator specifies the character to be used as a column sperator. Defaults to a comma character
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Row}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public String getCellRangeAsCsv(
			String spreadsheet,
			String worksheet,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex,
            @Default(",") String columnSeparator,
            @Default("\n") String lineSeparator,
            @Optional Integer minRow,
			@Optional Integer maxRow,
			@Optional Integer minCol,
			@Optional Integer maxCol) throws IOException, ServiceException {
    	
    	if (StringUtils.isEmpty(lineSeparator)) {
    		lineSeparator = "\n";
    	}
    	
    	if (StringUtils.isEmpty(",")) {
    		columnSeparator = ",";
    	}
    	
    	List<Row> rows = this.getCellRange(spreadsheet, worksheet, 
    			spreadsheetIndex, worksheetIndex, minRow, maxRow, minCol, maxCol);
    	
    	return ModelParser.toCSV(rows, lineSeparator, columnSeparator);
    }

    /**
     * Performs a full-text search on a worksheet and returns a list of {@link org.mule.module.google.spreadsheet.model.Row} 
     * in which each entry represent a cell containing a matching value
     * 
     * {@sample.xml ../../../doc/GoogleSpreadSheets-connector.xml.sample GoogleSpreadSheets:search}
     * 
     * @param spreadsheet the title of the spreadsheet containing the worksheet on which the cells are 
     * @param worksheet the title of the worksheet containing the cells you want to get
     * @param query a full text search string, with space-separated keywords
     * @param spreadsheetIndex google's api allows for several spreadsheet to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @param worksheetIndex google's api allows for several worksheets to have the same name. In this cases
     * 							it returns a list with all the ones matching the given title. Use this optional
     * 							attribute to specify the zero-based list index of the want you want to use
     * @return a list of {@link org.mule.module.google.spreadsheet.model.Cell}
     * @throws IOException if there's a communication error with google's servers
     * @throws ServiceException if the operation raises an error on google's end
     */
    @Processor
    public List<Row> search(
			String spreadsheet,
    		String worksheet,
    		String query,
            @Default("0") int spreadsheetIndex,
            @Default("0") int worksheetIndex) throws IOException, ServiceException {

        CellQuery cellQuery = new CellQuery(this.getCellFeedUrl(spreadsheet, worksheet, spreadsheetIndex, worksheetIndex));
      cellQuery.setFullTextQuery(query);
      
      return ModelParser.parseCell(this.spreadsheetService.query(cellQuery, CellFeed.class));
    }
    
    private SpreadsheetEntry getSpreadsheetEntry(
    		String spreadsheet,
    		int spreadsheetIndex) throws IOException, ServiceException {
    	
    	SpreadsheetQuery spreadsheetQuery = new SpreadsheetQuery(factory.getSpreadsheetsFeedUrl());
        spreadsheetQuery.setTitleQuery(spreadsheet);
    	return this.getItem(this.spreadsheetService.query(spreadsheetQuery, SpreadsheetFeed.class).getEntries(), spreadsheetIndex);
    }
    
    private List<WorksheetEntry> getWorksheetEntriesByTitle(
											String spreadsheet,
											String worksheet,
											int spreadsheetIndex) throws IOException, ServiceException {
    	
    	SpreadsheetEntry spreadsheetEntry = this.getSpreadsheetEntry(spreadsheet, spreadsheetIndex);
    	
    	WorksheetQuery worksheetQuery = new WorksheetQuery(spreadsheetEntry.getWorksheetFeedUrl());
    	worksheetQuery.setTitleQuery(worksheet);
    	return this.spreadsheetService.query(worksheetQuery, WorksheetFeed.class).getEntries();
    }
    
    private WorksheetEntry getWorksheetEntry(
    		String accessToken,
			String spreadsheet,
    		String worksheet,
    		int spreadsheetIndex,
    		int worksheetIndex) throws IOException, ServiceException {
    	
    	List<WorksheetEntry> worksheets = this.getWorksheetEntriesByTitle(spreadsheet, worksheet, spreadsheetIndex);
    	return this.getItem(worksheets, worksheetIndex);
    }
    
    private URL getCellFeedUrl(
    		String spreadsheet,
    		String worksheet,
    		int spreadsheetIndex,
    		int worksheetIndex) throws IOException, ServiceException {
    	
    	return this.getWorksheetEntry(accessToken, spreadsheet, worksheet, spreadsheetIndex, worksheetIndex).getCellFeedUrl();
    }
    
    private <T> T getItem(List<T> list, int index) {
    	if (list.isEmpty()) {
    		throw new IllegalArgumentException("No item found for that name");
    	} else if (index >= list.size()) {
    		throw new IllegalArgumentException("You requested item index " + index + 
    											" but only " + list.size() + " were found");
    	}
    	
    	return list.get(index);
    }
	
}
